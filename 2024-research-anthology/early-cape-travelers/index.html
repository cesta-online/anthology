<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

  <meta charset="utf-8">
  <meta name="generator" content="quarto-1.5.57">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


  <title>Early Cape Travelers</title>  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  .prj-lead {
      font-weight: bold; /* Matches the size of the main title */
      color: #734675; /* Plum purple color */ /* Adds some space between the two titles */
      font-size: 1em;
    }
  </style>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/css/style.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/css/style-quarto.css">
  <script src="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/js/script.js"></script>
  
<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
    <script id="quarto-search-options" type="application/json">{
      "location": "sidebar",
      "copy-button": false,
      "collapse-after": 3,
      "panel-placement": "start",
      "type": "textbox",
      "limit": 50,
      "keyboard-shortcut": [
        "f",
        "/",
        "s"
      ],
      "show-item-context": false,
      "language": {
        "search-no-results-text": "No results",
        "search-matching-documents-text": "matching documents",
        "search-copy-link-title": "Copy link to search",
        "search-hide-matches-text": "Hide additional matches",
        "search-more-match-text": "more match in this document",
        "search-more-matches-text": "more matches in this document",
        "search-clear-button-title": "Clear",
        "search-text-placeholder": "",
        "search-detached-cancel-button-title": "Cancel",
        "search-submit-button-title": "Submit",
        "search-label": "Search"
      }
    }</script>
  
  
  </head>

<body>

    <div id="quarto-search-results"></div>
    <!-- content -->
    <div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
    <!-- sidebar -->
    <!-- margin-sidebar -->
        <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
            <nav id="TOC" role="doc-toc" class="toc-active">
        <h2 id="toc-title">Contents</h2>
       
      <ul>
      <li><a href="#transcribing-peter-kolb-and-the-early-cape-of-good-hope" id="toc-transcribing-peter-kolb-and-the-early-cape-of-good-hope" class="nav-link active" data-scroll-target="#transcribing-peter-kolb-and-the-early-cape-of-good-hope">Transcribing Peter Kolb and the Early Cape of Good Hope</a>
      <ul class="collapse">
      <li><a href="#book-layouts" id="toc-book-layouts" class="nav-link" data-scroll-target="#book-layouts">Book Layouts</a></li>
      <li><a href="#extraction-methods" id="toc-extraction-methods" class="nav-link" data-scroll-target="#extraction-methods">Extraction Methods</a></li>
      <li><a href="#text-outputs" id="toc-text-outputs" class="nav-link" data-scroll-target="#text-outputs">Text Outputs</a></li>
      </ul></li>
      </ul>
    </nav>
        </div>
    <!-- main -->
    <main class="content" id="quarto-document-content">
  
    <header id="title-block-header">
      <p class="session">Summer 2024</p>
      <h1 class="title display-7">Early Cape Travelers</h1>
      <p class="prj-lead">Project Lead: Grant Parker</p> <!-- New title added -->
        <div class="project-description-container">
        <p class="project-description"></p><p>From roughly 1488 to 1900, the colonial Cape of Good Hope was the subject of numerous travel accounts by Europeans. Despite the obvious ethnocentrism of their colonial perspective, these accounts are historically valuable for the unique information they contain, including details on natural history, ethnography, and topography. While these travel accounts typically feature basic maps, the goal of the Early Cape Travelers project is to create high-quality digital maps for as many itineraries as possible. By mapping a critical mass of these texts with ArcGIS, we aim to detect broader geographical patterns that transcend any single journey, such as the persistence of certain routes over time and divergences from them. This is the focus of our first project this summer. Also, while many of these key texts, operating as our”sources” for the mapping, have been edited with commentary and translation by the Historical Publications of South Africa (HiPSA), many others still await high-quality new editions and translations, and this is the focus of our second project this summer.</p><p></p>
      </div>
      
    </header>
    <!-- <div class="header-img-container">
      <img src="data/imgs/etc-sps-headerimage-edited.jpg" alt=" header image"></img>
    </div>
     -->
    <div class="project-details-container">
        <div class="project-members-container">
        <div class="d-sm-none d-block">
          <h4 class="anchored">Project Members</h4>
        </div>
        <div class="row d-sm-flex d-none">
          <div class="col-sm">
            <p>Project Member</p>
          </div>
          <div class="col-sm">
            <p>Designation</p>
          </div>
            <div class="project-member row">
          <div class="col-sm">
            <p class="name">Grant Parker</p>
          </div>
          <div class="col-sm">
            <p class="designation">Associate Professor of Classics and African and African American Studies</p>
          </div>
        </div>
            <div class="project-member row">
          <div class="col-sm">
            <p class="name">Sam Prieto Serrano</p>
          </div>
          <div class="col-sm">
            <p class="designation">Undergraduate Researcher, Summer 2024</p>
          </div>
            </div>
          </div>
        
    </div>  

      
  <section id="transcribing-peter-kolb-and-the-early-cape-of-good-hope" class="level1">
  <h1>Transcribing Peter Kolb and the Early Cape of Good Hope</h1>
  <div class="article-author">
  <p>Sam Prieto Serrano</p>
  </div>
  <p>At the beginning of my internship, I was introduced to Peter Kolb, an 18th century German explorer and naturalist, and his book “Caput Bonae Spei Hodiernum” or “The Present Cape of Good Hope.” Written in High German and published in 1719, the book covers Kolb’s 7 years at the Cape, and in it he details its geography, flora, fauna, indigenous peoples, and Dutch colonial settlement.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-kolbportrait.png" class="img-fluid figure-img"></p>
  <figcaption>Figure 1. Portrait of Peter Kolb in 1727.</figcaption>
  </figure>
  </div>
  <p>My task was to make Kolb’s book, which existed only in images, into machine-readable and editable text in order to be used for later research. To begin the trancription journey, I familiarized myself with the book’s layout and manually skimmed all 992 images, tagging them based on common layouts. About 750 pages had two columns of text with minor outer-margin text (Group A), while the rest of the pages had varying layouts with columns, headings, tables, or images (Group B). Thus, my first challenge was finding transcription tools that handled the two biggest hurdles of the book: understanding early-modern Fraktur German print writing, and secondly, recognizing the reading order between columns and headers.</p>
  <section id="book-layouts" class="level2">
  <h2 class="anchored" data-anchor-id="book-layouts">Book Layouts</h2>
  <p>Below are sample pages displaying three of the various page layouts found in the book. The first image shows text belonging to one of the chapters. Note that about 80% of the book has this text layout. The second image shows the ending of a chapter followed by the title and beginning of the next. Finally, the third image shows one of the 80 index pagess found at the end of the book.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-textualimage-1.jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 2. Layout of the entire Group A.</figcaption>
  </figure>
  </div>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-textualimage-2.jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 3. Layout belonging to Group B.</figcaption>
  </figure>
  </div>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-textualimage-3.jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 4. Layout belonging to Group B.</figcaption>
  </figure>
  </div>
  </section>
  <section id="extraction-methods" class="level2">
  <h2 class="anchored" data-anchor-id="extraction-methods">Extraction Methods</h2>
  <p>After experimentation with many large-laguage models (LLMs), open-source software, and web apps, I found an efficient combination of methods and tools to complete the transcription.</p>
  <p>For Group A, I was able to write a Python script for Google Cloud Platform’s “Vertex Vision AI” API. In my script, I take each page as an image, crop it into regions using predetermined coordinates, pass the regions to the Vision AI processor, and I get text output in the same order as the regions. For Group B, which had layouts too complex to crop into regions systematically, I used the Transkribus transcription platform. Within Transkribus, I manually created ‘bounding boxes’ over every text region I deemed necessary, ran a Transkribus pre-trained LLM, and then edited or organized the text around the model’s errors.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/etc-sps-pipelinegraphic.png" class="img-fluid figure-img"></p>
  <figcaption>Figure 5. This flowchart illustrates the text processing pipeline followed in this project (from left to right).</figcaption>
  </figure>
  </div>
  </section>
  <section id="text-outputs" class="level2">
  <h2 class="anchored" data-anchor-id="text-outputs">Text Outputs</h2>
  <p>After weeks of text extraction, I moved to post-processing and correcting the exported files. This consisted of using a handful of NLP open-source software to correct things small (like removing or inserting spaces where needed) to large (like spell checking all 550k+ German words). I found that all spell checking tools available seemed to not handle the historical and domain-specific vocabulary of the book that well. This led me to create and feed my own dictionary of German words compiled fromm archival texts published between 1500 and 1800 into a custom spell checker program.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/etc-sps-linechart.png" class="img-fluid figure-img"></p>
  <figcaption>Figure 6. Line graph visualizing the number of misspellings in each page processed with the custom spell checker script.</figcaption>
  </figure>
  </div>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-frequencychart.png" class="img-fluid figure-img"></p>
  <figcaption>Figure 7. Radial hierarchy graph visualizing the top 50 most commonly misspelled words by part-of-speech. Provides insights into how the coherence of the text has been affected by the transcription process.</figcaption>
  </figure>
  </div>
  <p>I can make the assumption that the various spikes in misspellings are likely due to the topic covered in certain chapters. If the discussion in those pages includes domain-specific vocabulary (while covering Hottentoten-specific scenes, for instance), then it is possible words in those pages will be be scare or unseen elsewhere in contemporary German publishings, which is the data used to train the spell checker.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/ect-sps-docxvisual.jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 8. Sample view of a page within the compiled Docx.</figcaption>
  </figure>
  </div>
  <p>Ultimately, I was able to bring all text, images, and tables together into a Docx document that is readable, editable, and searchable for specific content depending on the research goals. Along the way, I also produced clean and corrected txt files for the book that are ready for future text processing or analysis methods.</p>
  
  
  </section>
  </section>

    </main> <!-- /main -->
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const icon = "";
      const anchorJS = new window.AnchorJS();
      anchorJS.options = {
        placement: 'right',
        icon: icon
      };
      anchorJS.add('.anchored');
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const onCopySuccess = function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      }
      const getTextToCopy = function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
        text: getTextToCopy
      });
      clipboard.on('success', onCopySuccess);
      if (window.document.getElementById('quarto-embedded-source-code-modal')) {
        // For code content inside modals, clipBoardJS needs to be initialized with a container option
        // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
        const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
          text: getTextToCopy,
          container: window.document.getElementById('quarto-embedded-source-code-modal')
        });
        clipboardModal.on('success', onCopySuccess);
      }
        var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
        var mailtoRegex = new RegExp(/^mailto:/);
          var filterRegex = new RegExp('/' + window.location.host + '/');
        var isInternal = (href) => {
            return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
        }
        // Inspect non-navigation links and adorn them if external
     	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
        for (var i=0; i<links.length; i++) {
          const link = links[i];
          if (!isInternal(link.href)) {
            // undo the damage that might have been done by quarto-nav.js in the case of
            // links that we want to consider external
            if (link.dataset.originalHref !== undefined) {
              link.href = link.dataset.originalHref;
            }
          }
        }
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note) {
            return note.innerHTML;
          } else {
            return "";
          }
        });
      }
      const xrefs = window.document.querySelectorAll('a.quarto-xref');
      const processXRef = (id, note) => {
        // Strip column container classes
        const stripColumnClz = (el) => {
          el.classList.remove("page-full", "page-columns");
          if (el.children) {
            for (const child of el.children) {
              stripColumnClz(child);
            }
          }
        }
        stripColumnClz(note)
        if (id === null || id.startsWith('sec-')) {
          // Special case sections, only their first couple elements
          const container = document.createElement("div");
          if (note.children && note.children.length > 2) {
            container.appendChild(note.children[0].cloneNode(true));
            for (let i = 1; i < note.children.length; i++) {
              const child = note.children[i];
              if (child.tagName === "P" && child.innerText === "") {
                continue;
              } else {
                container.appendChild(child.cloneNode(true));
                break;
              }
            }
            if (window.Quarto?.typesetMath) {
              window.Quarto.typesetMath(container);
            }
            return container.innerHTML
          } else {
            if (window.Quarto?.typesetMath) {
              window.Quarto.typesetMath(note);
            }
            return note.innerHTML;
          }
        } else {
          // Remove any anchor links if they are present
          const anchorLink = note.querySelector('a.anchorjs-link');
          if (anchorLink) {
            anchorLink.remove();
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          // TODO in 1.5, we should make sure this works without a callout special case
          if (note.classList.contains("callout")) {
            return note.outerHTML;
          } else {
            return note.innerHTML;
          }
        }
      }
      for (var i=0; i<xrefs.length; i++) {
        const xref = xrefs[i];
        tippyHover(xref, undefined, function(instance) {
          instance.disable();
          let url = xref.getAttribute('href');
          let hash = undefined; 
          if (url.startsWith('#')) {
            hash = url;
          } else {
            try { hash = new URL(url).hash; } catch {}
          }
          if (hash) {
            const id = hash.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note !== null) {
              try {
                const html = processXRef(id, note.cloneNode(true));
                instance.setContent(html);
              } finally {
                instance.enable();
                instance.show();
              }
            } else {
              // See if we can fetch this
              fetch(url.split('#')[0])
              .then(res => res.text())
              .then(html => {
                const parser = new DOMParser();
                const htmlDoc = parser.parseFromString(html, "text/html");
                const note = htmlDoc.getElementById(id);
                if (note !== null) {
                  const html = processXRef(id, note);
                  instance.setContent(html);
                } 
              }).finally(() => {
                instance.enable();
                instance.show();
              });
            }
          } else {
            // See if we can fetch a full url (with no hash to target)
            // This is a special case and we should probably do some content thinning / targeting
            fetch(url)
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.querySelector('main.content');
              if (note !== null) {
                // This should only happen for chapter cross references
                // (since there is no id in the URL)
                // remove the first header
                if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                  note.children[0].remove();
                }
                const html = processXRef(null, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        }, function(instance) {
        });
      }
          let selectedAnnoteEl;
          const selectorForAnnotation = ( cell, annotation) => {
            let cellAttr = 'data-code-cell="' + cell + '"';
            let lineAttr = 'data-code-annotation="' +  annotation + '"';
            const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
            return selector;
          }
          const selectCodeLines = (annoteEl) => {
            const doc = window.document;
            const targetCell = annoteEl.getAttribute("data-target-cell");
            const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
            const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            const lines = annoteSpan.getAttribute("data-code-lines").split(",");
            const lineIds = lines.map((line) => {
              return targetCell + "-" + line;
            })
            let top = null;
            let height = null;
            let parent = null;
            if (lineIds.length > 0) {
                //compute the position of the single el (top and bottom and make a div)
                const el = window.document.getElementById(lineIds[0]);
                top = el.offsetTop;
                height = el.offsetHeight;
                parent = el.parentElement.parentElement;
              if (lineIds.length > 1) {
                const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
                const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                height = bottom - top;
              }
              if (top !== null && height !== null && parent !== null) {
                // cook up a div (if necessary) and position it 
                let div = window.document.getElementById("code-annotation-line-highlight");
                if (div === null) {
                  div = window.document.createElement("div");
                  div.setAttribute("id", "code-annotation-line-highlight");
                  div.style.position = 'absolute';
                  parent.appendChild(div);
                }
                div.style.top = top - 2 + "px";
                div.style.height = height + 4 + "px";
                div.style.left = 0;
                let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
                if (gutterDiv === null) {
                  gutterDiv = window.document.createElement("div");
                  gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                  gutterDiv.style.position = 'absolute';
                  const codeCell = window.document.getElementById(targetCell);
                  const gutter = codeCell.querySelector('.code-annotation-gutter');
                  gutter.appendChild(gutterDiv);
                }
                gutterDiv.style.top = top - 2 + "px";
                gutterDiv.style.height = height + 4 + "px";
              }
              selectedAnnoteEl = annoteEl;
            }
          };
          const unselectCodeLines = () => {
            const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
            elementsIds.forEach((elId) => {
              const div = window.document.getElementById(elId);
              if (div) {
                div.remove();
              }
            });
            selectedAnnoteEl = undefined;
          };
            // Handle positioning of the toggle
        window.addEventListener(
          "resize",
          throttle(() => {
            elRect = undefined;
            if (selectedAnnoteEl) {
              selectCodeLines(selectedAnnoteEl);
            }
          }, 10)
        );
        function throttle(fn, ms) {
        let throttle = false;
        let timer;
          return (...args) => {
            if(!throttle) { // first call gets through
                fn.apply(this, args);
                throttle = true;
            } else { // all the others get throttled
                if(timer) clearTimeout(timer); // cancel #2
                timer = setTimeout(() => {
                  fn.apply(this, args);
                  timer = throttle = false;
                }, ms);
            }
          };
        }
          // Attach click handler to the DT
          const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
          for (const annoteDlNode of annoteDls) {
            annoteDlNode.addEventListener('click', (event) => {
              const clickedEl = event.target;
              if (clickedEl !== selectedAnnoteEl) {
                unselectCodeLines();
                const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
                if (activeEl) {
                  activeEl.classList.remove('code-annotation-active');
                }
                selectCodeLines(clickedEl);
                clickedEl.classList.add('code-annotation-active');
              } else {
                // Unselect the line
                unselectCodeLines();
                clickedEl.classList.remove('code-annotation-active');
              }
            });
          }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    </div> <!-- /content -->
  


</body></html>
