<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

  <meta charset="utf-8">
  <meta name="generator" content="quarto-1.5.55">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


  <title>Syriac Verb Tutorial</title>  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
  .prj-lead {
      font-weight: bold; /* Matches the size of the main title */
      color: #734675; /* Plum purple color */ /* Adds some space between the two titles */
      font-size: 1em;
    }
  </style>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/css/style.css">
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/css/style-quarto.css">
  <script src="https://cdn.jsdelivr.net/gh/cesta-online/anthology-assets@latest/js/script.js"></script>
  
<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
    <script id="quarto-search-options" type="application/json">{
      "location": "sidebar",
      "copy-button": false,
      "collapse-after": 3,
      "panel-placement": "start",
      "type": "textbox",
      "limit": 50,
      "keyboard-shortcut": [
        "f",
        "/",
        "s"
      ],
      "show-item-context": false,
      "language": {
        "search-no-results-text": "No results",
        "search-matching-documents-text": "matching documents",
        "search-copy-link-title": "Copy link to search",
        "search-hide-matches-text": "Hide additional matches",
        "search-more-match-text": "more match in this document",
        "search-more-matches-text": "more matches in this document",
        "search-clear-button-title": "Clear",
        "search-text-placeholder": "",
        "search-detached-cancel-button-title": "Cancel",
        "search-submit-button-title": "Submit",
        "search-label": "Search"
      }
    }</script>
  
  
  </head>

<body>

    <div id="quarto-search-results"></div>
    <!-- content -->
    <div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
    <!-- sidebar -->
    <!-- margin-sidebar -->
        <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
            <nav id="TOC" role="doc-toc" class="toc-active">
        <h2 id="toc-title">Contents</h2>
       
      <ul>
      <li><a href="#syriac-verb-tutorial-gamificaton" id="toc-syriac-verb-tutorial-gamificaton" class="nav-link active" data-scroll-target="#syriac-verb-tutorial-gamificaton">Syriac Verb Tutorial Gamificaton</a></li>
      </ul>
    </nav>
        </div>
    <!-- main -->
    <main class="content" id="quarto-document-content">
  
    <header id="title-block-header">
      <p class="session">Summer 2024</p>
      <h1 class="title display-7">Syriac Verb Tutorial</h1>
      <p class="prj-lead">Project Lead: Michael Penn </p> <!-- New title added -->
        <div class="project-description-container">
        <p class="project-description">Most early Christian literature was written in one of three languages: in Greek, in Latin, or in a dialect of Aramaic called Syriac. Between the second and tenth centuries CE the last of these languages, Syriac, was the lingua franca of the late ancient Middle East. There are about ten million modern Christians, from what is modern day Eastern Turkey, Syria, Iraq, Iran, Southern India, and now in diaspora that trace their lineage to the ancient Syriac churches. But because of its focus on more western branches of Christianity, there are only a handful of modern scholars who are able to read this important language of pre-modern Christianity. So, too, there are very minimal pedagogical resources for teaching or learning this endangered language. For example, although there are a few textbooks on first year Syriac, there isn’t a single textbook for intermediate or advanced study. This has become particularly problematic in the teaching and learning of Syriac’s complicated verbal system. Currently most students of Syriac simply try to memorize large charts of verbal paradigms. But as there is not a single workbook or other resource by which to drill and reinforce one’s knowledge of Syriac verbs, this remains an ineffective system of study and instruction.</p>
      </div>
      
    </header>
    <!-- <div class="header-img-container">
      <img src="data/imgs/placeholder.jpg" alt=" header image"></img>
    </div>
     -->
    <div class="project-details-container">
        <div class="project-members-container">
        <div class="d-sm-none d-block">
          <h4 class="anchored">Project Members</h4>
        </div>
        <div class="row d-sm-flex d-none">
          <div class="col-sm">
            <p>Project Team</p>
          </div>
          <div class="col-sm">
            <p></p>
          </div>
        </div>
            <div class="project-member row">
          <div class="col-sm">
            <p class="name">Michael Penn</p>
          </div>
          <div class="col-sm">
            <p class="designation">Professor or Religious Studies</p>
          </div>
        </div>
            <div class="project-member row">
          <div class="col-sm">
            <p class="name">Erick Angelo Ramirez</p>
          </div>
          <div class="col-sm">
            <p class="designation">Undergraduate Researcher - Summer, 2024</p>
          </div>
        </div>
          </div>
        
    </div>  

      
  <section id="syriac-verb-tutorial-gamificaton" class="level1">
  <h1>Syriac Verb Tutorial Gamificaton</h1>
  <div class="article-author">
  <p>Erick Angelo Ramirez</p>
  </div>
  <p>The Syriac Verb Tutorial project is a language-learning initiative supported by the Center for Spatial and Textual Analysis (CESTA) at Stanford University. This web application provides a space for Syriac language learners, educators, and researchers to improve proficiency in the language. The platform includes various tools designed to enhance engagement with Syriac verb forms, such as a Verb Construction mode (for conjugating verbs) and a Verb Identification mode (for recognizing verb forms).</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/Ramirez,CESTA,3 (1).jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 1. The Syriac language has a complex verbal system. A single verb stem can have up to 186 different conjugations, varying in their forms, tenses, persons, genders, and numbers.</figcaption>
  </figure>
  </div>
  <p>Over the summer, I initially focused on updating the existing Syriac verb tutorial by debugging certain features and adding final touches to improve the user experience. Then, I brainstormed and developed gamification features to make learning Syriac verb conjugations and identification more engaging. One interactive game I created is a PGN Matching activity where users match the correct person-gender-number (PGN) with a given verb conjugation. This game aims to tackle the complex nature of Syriac verb conjugations, as a single verb stem can have up to 186 different conjugations depending on its form, tense, and PGN. The game allows users to set a countdown timer and select the types, forms, and tenses of the verbs they want to practice. Players then try to match as many verb conjugations as possible within the time limit to increase their score. At the end of the game, users receive a list of all the verb conjugations they encountered, along with their correct and incorrect answers, allowing them to review and learn from their performance.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/Ramirez,CESTA,1 (1).jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 2. PGN Matching Game</figcaption>
  </figure>
  </div>
  <p>I also began prototyping another game, called the Vowel Placement Game, which focuses on unvocalized conjugations—conjugations with the vowels omitted. In this game, users are presented with a verb conjugation in its unvocalized form, along with its specified form, tense, and PGN markers. The objective is to drag and drop the correct vowels above the corresponding consonants to reconstruct the full vocalization of the verb. This interactive activity not only reinforces users’ understanding of Syriac vowel patterns but also deepens their grasp of how vowel placement differs with different verb forms, tenses, and PGNs. As players correctly place vowels, they gain immediate feedback, which helps them learn the correct vocalization rules and patterns. By repeatedly practicing with unvocalized verbs, learners can improve their ability to recognize and vocalize Syriac verbs accurately, enhancing their overall language proficiency.</p>
  <div class="quarto-figure quarto-figure-center">
  <figure class="figure">
  <p><img src="data/imgs/Ramirez,CESTA,2 (1).jpg" class="img-fluid figure-img"></p>
  <figcaption>Figure 3. Vowel Placement Game</figcaption>
  </figure>
  </div>
  <p>By developing tools that make learning Syriac more engaging and accessible, this project aims to bridge a significant gap in language education. Syriac, an ancient Aramaic dialect, was once the lingua franca of vast Christian communities stretching from Eastern Turkey and the Middle East to Afghanistan, Tibet, China, and India during the early and medieval periods. These communities played a critical role in the spread of Christianity and in the exchange of cultural, scientific, and theological ideas across different civilizations. Understanding Syriac is not just about learning a language; it’s about connecting with this rich history and the cultural and religious traditions that have shaped a large part of the world. Despite its historical importance, few people today can read Syriac, and resources for studying it, especially at advanced levels, are limited. By making these learning resources available, we support the preservation of the Syriac language and its cultural heritage, ensuring that it remains a vibrant and accessible part of the world’s historical narrative for future generations of scholars and students.</p>
  
  
  </section>

    </main> <!-- /main -->
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const icon = "";
      const anchorJS = new window.AnchorJS();
      anchorJS.options = {
        placement: 'right',
        icon: icon
      };
      anchorJS.add('.anchored');
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const onCopySuccess = function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      }
      const getTextToCopy = function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
        text: getTextToCopy
      });
      clipboard.on('success', onCopySuccess);
      if (window.document.getElementById('quarto-embedded-source-code-modal')) {
        // For code content inside modals, clipBoardJS needs to be initialized with a container option
        // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
        const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
          text: getTextToCopy,
          container: window.document.getElementById('quarto-embedded-source-code-modal')
        });
        clipboardModal.on('success', onCopySuccess);
      }
        var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
        var mailtoRegex = new RegExp(/^mailto:/);
          var filterRegex = new RegExp('/' + window.location.host + '/');
        var isInternal = (href) => {
            return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
        }
        // Inspect non-navigation links and adorn them if external
     	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
        for (var i=0; i<links.length; i++) {
          const link = links[i];
          if (!isInternal(link.href)) {
            // undo the damage that might have been done by quarto-nav.js in the case of
            // links that we want to consider external
            if (link.dataset.originalHref !== undefined) {
              link.href = link.dataset.originalHref;
            }
          }
        }
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note) {
            return note.innerHTML;
          } else {
            return "";
          }
        });
      }
      const xrefs = window.document.querySelectorAll('a.quarto-xref');
      const processXRef = (id, note) => {
        // Strip column container classes
        const stripColumnClz = (el) => {
          el.classList.remove("page-full", "page-columns");
          if (el.children) {
            for (const child of el.children) {
              stripColumnClz(child);
            }
          }
        }
        stripColumnClz(note)
        if (id === null || id.startsWith('sec-')) {
          // Special case sections, only their first couple elements
          const container = document.createElement("div");
          if (note.children && note.children.length > 2) {
            container.appendChild(note.children[0].cloneNode(true));
            for (let i = 1; i < note.children.length; i++) {
              const child = note.children[i];
              if (child.tagName === "P" && child.innerText === "") {
                continue;
              } else {
                container.appendChild(child.cloneNode(true));
                break;
              }
            }
            if (window.Quarto?.typesetMath) {
              window.Quarto.typesetMath(container);
            }
            return container.innerHTML
          } else {
            if (window.Quarto?.typesetMath) {
              window.Quarto.typesetMath(note);
            }
            return note.innerHTML;
          }
        } else {
          // Remove any anchor links if they are present
          const anchorLink = note.querySelector('a.anchorjs-link');
          if (anchorLink) {
            anchorLink.remove();
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          // TODO in 1.5, we should make sure this works without a callout special case
          if (note.classList.contains("callout")) {
            return note.outerHTML;
          } else {
            return note.innerHTML;
          }
        }
      }
      for (var i=0; i<xrefs.length; i++) {
        const xref = xrefs[i];
        tippyHover(xref, undefined, function(instance) {
          instance.disable();
          let url = xref.getAttribute('href');
          let hash = undefined; 
          if (url.startsWith('#')) {
            hash = url;
          } else {
            try { hash = new URL(url).hash; } catch {}
          }
          if (hash) {
            const id = hash.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note !== null) {
              try {
                const html = processXRef(id, note.cloneNode(true));
                instance.setContent(html);
              } finally {
                instance.enable();
                instance.show();
              }
            } else {
              // See if we can fetch this
              fetch(url.split('#')[0])
              .then(res => res.text())
              .then(html => {
                const parser = new DOMParser();
                const htmlDoc = parser.parseFromString(html, "text/html");
                const note = htmlDoc.getElementById(id);
                if (note !== null) {
                  const html = processXRef(id, note);
                  instance.setContent(html);
                } 
              }).finally(() => {
                instance.enable();
                instance.show();
              });
            }
          } else {
            // See if we can fetch a full url (with no hash to target)
            // This is a special case and we should probably do some content thinning / targeting
            fetch(url)
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.querySelector('main.content');
              if (note !== null) {
                // This should only happen for chapter cross references
                // (since there is no id in the URL)
                // remove the first header
                if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                  note.children[0].remove();
                }
                const html = processXRef(null, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        }, function(instance) {
        });
      }
          let selectedAnnoteEl;
          const selectorForAnnotation = ( cell, annotation) => {
            let cellAttr = 'data-code-cell="' + cell + '"';
            let lineAttr = 'data-code-annotation="' +  annotation + '"';
            const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
            return selector;
          }
          const selectCodeLines = (annoteEl) => {
            const doc = window.document;
            const targetCell = annoteEl.getAttribute("data-target-cell");
            const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
            const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            const lines = annoteSpan.getAttribute("data-code-lines").split(",");
            const lineIds = lines.map((line) => {
              return targetCell + "-" + line;
            })
            let top = null;
            let height = null;
            let parent = null;
            if (lineIds.length > 0) {
                //compute the position of the single el (top and bottom and make a div)
                const el = window.document.getElementById(lineIds[0]);
                top = el.offsetTop;
                height = el.offsetHeight;
                parent = el.parentElement.parentElement;
              if (lineIds.length > 1) {
                const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
                const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                height = bottom - top;
              }
              if (top !== null && height !== null && parent !== null) {
                // cook up a div (if necessary) and position it 
                let div = window.document.getElementById("code-annotation-line-highlight");
                if (div === null) {
                  div = window.document.createElement("div");
                  div.setAttribute("id", "code-annotation-line-highlight");
                  div.style.position = 'absolute';
                  parent.appendChild(div);
                }
                div.style.top = top - 2 + "px";
                div.style.height = height + 4 + "px";
                div.style.left = 0;
                let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
                if (gutterDiv === null) {
                  gutterDiv = window.document.createElement("div");
                  gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                  gutterDiv.style.position = 'absolute';
                  const codeCell = window.document.getElementById(targetCell);
                  const gutter = codeCell.querySelector('.code-annotation-gutter');
                  gutter.appendChild(gutterDiv);
                }
                gutterDiv.style.top = top - 2 + "px";
                gutterDiv.style.height = height + 4 + "px";
              }
              selectedAnnoteEl = annoteEl;
            }
          };
          const unselectCodeLines = () => {
            const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
            elementsIds.forEach((elId) => {
              const div = window.document.getElementById(elId);
              if (div) {
                div.remove();
              }
            });
            selectedAnnoteEl = undefined;
          };
            // Handle positioning of the toggle
        window.addEventListener(
          "resize",
          throttle(() => {
            elRect = undefined;
            if (selectedAnnoteEl) {
              selectCodeLines(selectedAnnoteEl);
            }
          }, 10)
        );
        function throttle(fn, ms) {
        let throttle = false;
        let timer;
          return (...args) => {
            if(!throttle) { // first call gets through
                fn.apply(this, args);
                throttle = true;
            } else { // all the others get throttled
                if(timer) clearTimeout(timer); // cancel #2
                timer = setTimeout(() => {
                  fn.apply(this, args);
                  timer = throttle = false;
                }, ms);
            }
          };
        }
          // Attach click handler to the DT
          const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
          for (const annoteDlNode of annoteDls) {
            annoteDlNode.addEventListener('click', (event) => {
              const clickedEl = event.target;
              if (clickedEl !== selectedAnnoteEl) {
                unselectCodeLines();
                const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
                if (activeEl) {
                  activeEl.classList.remove('code-annotation-active');
                }
                selectCodeLines(clickedEl);
                clickedEl.classList.add('code-annotation-active');
              } else {
                // Unselect the line
                unselectCodeLines();
                clickedEl.classList.remove('code-annotation-active');
              }
            });
          }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    </div> <!-- /content -->
  


</body></html>
